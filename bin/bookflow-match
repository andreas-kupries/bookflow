#!/usr/bin/env tclsh
# -*- tcl -*-
# # ## ### ##### ######## ############# #####################

# Take the current project for the user to go over the images and
# match left and right sides of a double page to each other. As part
# of that image flags may be changed, i.e bad images removed and/or
# reoriented. Uses the upright images for display.

# Additional concepts here:
# - Blank pages : Content pgages without content. Can be excluded from
#                 any future processing.
#
# - Missing pages : Pages which should be present, but were either not
#                   photographed, or whose page images are not good
#                   enough for further processing. In the latter case
#                   the origin image will be marked as 'not used'.
#
# - Order : Before this point page order was heuristically derived
#           from the image order, and the left/right annotations. From
#           now on image and page order are known exactly.

# # ## ### ##### ######## ############# #####################

package require Tcl 8.5

::apply {{selfdir} {
    # selfdir == bindir
    lappend ::auto_path [file dirname $selfdir]/lib
    return
}} [file dirname [file normalize [info script]]]

# TODO: Restrict to images of a certain size and/or make (camera type).

package require Tk  8.5
package require widget::toolbar
package require widget::statusbar
package require widget::scrolledwindow

# Would prefer to have a widget::progressbar
package require BWidget ; ProgressBar::use

package require bookflow::project
package require crimp::tk  ;# crimp -> photo
package require crimp::ppm ;# crimp -> reading ppm
# XXX TODO: crimp::jpeg
package require action
package require famfamfam::silk
package require tooltip

# # ## ### ##### ######## ############# #####################

proc main {} {
    if {[catch {
	cmdline
	view
	controller
	model
    } msg]} {
puts $::errorInfo
	puts stderr $msg
	exit 1
    }

    # Begin event loop, and interaction
    vwait ::forever
    return
}

proc cmdline {} {
    global argv argv0
    if {[llength $argv] > 1} {
	puts stderr "Usage: $argv0 ?projectdir?"
	exit 1
    }
    if {[llength $argv] == 1} {
	cd [lindex $argv 0]
    }

    # Open the project file.
    bookflow::project BOOK [pwd]/BOOKFLOW
    return
}

# # ## ### ##### ######## ############# #####################
## View

proc view {} {
    wm withdraw .
    view/widgets
    view/layout
    wm deiconify .
    return
}

proc view/widgets {} {
    # listbox, left or right, of all images (fast switching).
    # various labels for status icons
    # label displaying the current page image
    # buttons: next, previous, first, last, exit - toolbar
    # statusbar - messages ...

    ::widget::toolbar   .tools
    ::widget::statusbar .status

    ttk::label          .status.message  \
	-textvariable ::vstatus \
	-width 1 -anchor w

    ProgressBar         .status.progress \
	-variable ::vprogress \
	-type infinite -orient horizontal \
	-bd 1 -relief sunken

    widget::scrolledwindow .lsw -borderwidth 1 -relief sunken
    listbox                .limages \
	-listvariable ::vimages(lpage) \
	-selectmode single

    widget::scrolledwindow .rsw -borderwidth 1 -relief sunken
    listbox                .rimages \
	-listvariable ::vimages(rpage) \
	-selectmode single

    label               .left  -bd 5
    label               .right -bd 5

    ttk::label          .lorient
    ttk::label          .lleft
    ttk::label          .lright
    ttk::label          .lattention
    ttk::label          .ldropped

    ttk::label          .rorient
    ttk::label          .rleft
    ttk::label          .rright
    ttk::label          .rattention
    ttk::label          .rdropped

    #view/tool/add arrow_left  |<--   First    first
    #view/tool/add arrow_left   <--   Previous previous
    #view/tool/add arrow_right   -->  Next     next
    #view/tool/add arrow_right   -->| Last     last
    view/tool/space
    view/tool/add asterisk_orange Exit Exit exit

    view/tag .
    return
}

proc view/tag {w} {
    bindtags $w [list _self {*}[bindtags $w]]
    foreach c [winfo children $w] {
	view/tag $c
    }
    return
}

proc view/tool/add {image label hint action args} {
    set     cmd {}
    lappend cmd .tools add button $label
    lappend cmd -text $label
    lappend cmd -command [list action invoke $action] {*}$args
    if {$image ne {}} {
	lappend cmd -image [famfamfam silk get $image]
    }

    {*}$cmd

    set w [.tools itemid $label]

    tooltip::tooltip $w $hint
    after 0 [list action link $action $w]
    return
}

proc view/tool/space {} {
    .tools add space  ____ -separator 1
    return
}

proc view/layout {} {
    global lpage rpage

    .lsw setwidget .limages
    .rsw setwidget .rimages

    .status add .status.message -weight 1
    .status add .status.progress

    grid columnconfigure . 0  -weight 0
    grid columnconfigure . 1  -weight 0
    grid columnconfigure . 2  -weight 0
    grid columnconfigure . 3  -weight 0
    grid columnconfigure . 4  -weight 0
    grid columnconfigure . 5  -weight 1
    grid columnconfigure . 6  -weight 0

    grid columnconfigure . 7  -weight 0
    grid columnconfigure . 8  -weight 1
    grid columnconfigure . 9  -weight 0
    grid columnconfigure . 10 -weight 0
    grid columnconfigure . 11 -weight 0
    grid columnconfigure . 12 -weight 0
    grid columnconfigure . 13 -weight 0

    grid rowconfigure    . 0 -weight 0
    grid rowconfigure    . 1 -weight 0
    grid rowconfigure    . 2 -weight 0
    grid rowconfigure    . 3 -weight 1
    grid rowconfigure    . 4 -weight 0

    view/layout/at .tools     0 0 1 14

    view/layout/at .lsw        1  0 3 1
    view/layout/at .lorient    1  1 1 1
    view/layout/at .lleft      1  2 1 1
    view/layout/at .lattention 1  3 1 1
    view/layout/at .ldropped   1  4 1 1
    view/layout/at .lright     1  6 1 1
    view/layout/at .left       3  1 1 6

    view/layout/at .right      3  7 1 6
    view/layout/at .rorient    1  7 1 1
    view/layout/at .rleft      1  8 1 1
    view/layout/at .rattention 1  9 1 1
    view/layout/at .rdropped   1 10 1 1
    view/layout/at .rright     1 12 1 1
    view/layout/at .rsw        1 13 3 1

    view/layout/at .status    4 0 1 14

    set lpage(images)    .limages
    set lpage(orient)    .lorient
    set lpage(left)      .lleft
    set lpage(attention) .lattention
    set lpage(dropped)   .ldropped
    set lpage(right)     .lright
    set lpage(page)      .left

    set rpage(images)    .rimages
    set rpage(orient)    .rorient
    set rpage(left)      .rleft
    set rpage(attention) .rattention
    set rpage(dropped)   .rdropped
    set rpage(right)     .rright
    set rpage(page)      .right
    return
}

proc view/layout/at {widget row col r c} {
    grid $widget -row $row -column $col \
	-sticky swen -rowspan $r -columnspan $c
    return
}

# # ## ### ##### ######## ############# #####################
# # ## ### ##### ######## ############# #####################
# View. Entrypoints for the controller.

proc view/status {text} {
    set ::vstatus $text
    return
}

proc view/progress/tick {} {
    .status add .status.progress
    incr ::vprogress
    return
}

proc view/progress/reset {} {
    catch { .status remove .status.progress }
    set ::vprogress 0
    return
}

proc view/show {side select index image used even content attention orientation} {
    global oicon
    upvar #0 $side w

    #puts "v/s |$select $index $image i$used e$even c$content a$attention|"
    catch { image delete [$w(page) cget -image] }
    $w(page) configure -image $image

    if {$attention} {
	$w(attention) configure -image [famfamfam silk get exclamation]
    } else {
	$w(attention) configure -image {}
    }

    if {$used} {
	$w(dropped) configure -image {}
    } else {
	$w(dropped) configure -image [famfamfam silk get cross]
    }

    if {$even} {
	$w(left)  configure -image [famfamfam silk get asterisk_yellow]
	$w(right) configure -image {}
    } else {
	$w(left)  configure -image {}
	$w(right) configure -image [famfamfam silk get asterisk_yellow]
    }

    $w(orient) configure -image [famfamfam silk get $oicon($orientation)]

    if {$content} { ; # content page
	$w(page) configure -bg blue
    } else {        ; # cover page
	$w(page) configure -bg green
    }

    # List visualization of the flags
    $w(images) itemconfigure $index \
	{*}[view/list/flags $used $even $content $attention $orientation]

    # Modify list
    if {$select} {
	#puts XS=$index
	$w(images) selection clear 0 end
	$w(images) selection set $index
	$w(images) activate $index
	c/selection $side
    }
    $w(images) see $index
    return
}

proc view/show/none {side} {
    upvar #0 $side w
    image delete [$w(page) cget -image]

    $w(page)      configure -image {} -bg black
    $w(orient)    configure -image {}
    $w(attention) configure -image {}
    $w(dropped)   configure -image {}
    $w(right)     configure -image {}
    $w(left)      configure -image {}
    return
}

proc view/list/fill {side images iflags} {
    upvar #0 $side w
    upvar #0 vimages($side) vimages

    set vimages $images
    set k 0
    foreach item $iflags {
	lassign $item _ used even content attention orientation
	$w(images) itemconfigure $k \
	    {*}[view/list/flags $used $even $content $attention $orientation]
	incr k
    }
    return
}

proc view/list/flags {used even content attention orientation} {
    set options {}

    if {$content} {
	lappend options -fg black
    } else {
	lappend options -fg green
    }
    if {!$used} {
	lappend options -bg red
    } elseif {$attention} {
	lappend options -bg yellow
    } else {
	lappend options -bg white
    }

    return $options
}

proc view/selection {side} {
    upvar #0 $side w
    return [$w(images) curselection]
}

# # ## ### ##### ######## ############# #####################
## Controller

proc controller {} {
    c/actions
    c/bindings

    after 0 c/launch
    return
}

proc c/actions {} {
    action define exit     ::exit

    action define left/next      c/show/next     lpage
    action define left/previous  c/show/previous lpage
    action define left/first     c/show/first    lpage
    action define left/last      c/show/last     lpage

    action define right/next      c/show/next     rpage
    action define right/previous  c/show/previous rpage
    action define right/first     c/show/first    rpage
    action define right/last      c/show/last     rpage

    #action define attention c/toggle/attention
    #action define drop      c/toggle/used
    #action define front     c/mark/cover_front
    #action define back      c/mark/cover_back
    #action define left      c/mark/even 1
    #action define right     c/mark/even 0
    #action define cover     c/mark/content 0
    #action define page      c/mark/content 1

    #action define east      c/orient east
    #action define south     c/orient south
    #action define west      c/orient west
    #action define north     c/orient north
    return
}

proc c/bindings {} {
    # Leave
    bind _self <q>      {action invoke exit ; break}

    # Navigation, Left
    bind _self <a>   {action invoke left/previous ; break}
    bind _self <s>   {action invoke left/next     ; break}
    bind _self <w>   {action invoke left/first    ; break}
    bind _self <z>   {action invoke left/last     ; break}

    # Navigation, Right
    bind _self <k>   {action invoke right/previous ; break}
    bind _self <l>   {action invoke right/next     ; break}
    bind _self <o>   {action invoke right/first    ; break}
    bind _self <m>   {action invoke right/last     ; break}

    # Selection
    bind .limages <<ListboxSelect>> {c/selection lpage}
    bind .rimages <<ListboxSelect>> {c/selection rpage}

    # Flags
    #bind _self <exclam> {action invoke attention ; break}
    #bind _self <d>      {action invoke drop      ; break}
    #bind _self <f>      {action invoke front     ; break}
    #bind _self <b>      {action invoke back      ; break}
    #bind _self <l>      {action invoke left      ; break}
    #bind _self <r>      {action invoke right     ; break}
    #bind _self <c>      {action invoke cover     ; break}
    #bind _self <p>      {action invoke page      ; break}

    # Orientation
    #bind _self <e>      {action invoke east      ; break}
    #bind _self <s>      {action invoke south     ; break}
    #bind _self <w>      {action invoke west      ; break}
    #bind _self <n>      {action invoke north     ; break}
    return
}

proc c/launch {} {
    action disable
    action enable exit

    m/initialize c/ready
    return
}

proc c/ready {} {
    global cimages cchosen

    set cchosen(lpage) {}
    set cchosen(rpage) {}

    lassign [m/list/left]  cimages(lpage) liflags
    lassign [m/list/right] cimages(rpage) riflags

    view/list/fill lpage $cimages(lpage) $liflags
    view/list/fill rpage $cimages(rpage) $riflags

    c/show/first lpage
    c/show/first rpage

    after 0 {action enable}
    return
}

# # ## ### ##### ######## ############# #####################
## Controller state, arrays, indexed by lpage, and rpage

global cimages  ; # list of shown images, left side
global cchosen  ; # index of the selected images
global cshown   ; # index of the shown image
global ccurrent ; # path of the shown image
global cflags   ; # flags of the shown image

# # ## ### ##### ######## ############# #####################
# # ## ### ##### ######## ############# #####################
# Implementations for the various actions

proc c/selection {side} {
    upvar #0 cchosen($side) cchosen
    set current [view/selection $side]
    #puts C=$current
    #puts S=$cchosen
    if {$current eq $cchosen} return
    set cchosen $current
    #puts S*$cchosen
    if {[llength $cchosen]} {
	c/show $side [lindex $cchosen 0] 0
    } else {
	c/show/none $side
    }
    return
}

proc c/load {side index} {
    upvar #0 \
	cshown($side)   cshown \
	ccurrent($side) ccurrent \
	cimages($side)  cimages \
	cflags($side)   cflags

    # Locate image by index, then translate index (possibly symbolic,
    # or relative) to a proper integer number.
    set ccurrent [lindex $cimages $index]
    set cshown   [lsearch -exact $cimages $ccurrent]
    set cflags   [lassign [m/get $ccurrent] image]
    return
}

proc c/show {side index {select 1}} {
    upvar #0 \
	cshown($side)   cshown \
	ccurrent($side) ccurrent \
	cimages($side)  cimages \
	cflags($side)   cflags

    # Locate image by index, then translate index (possibly symbolic,
    # or relative) to a proper integer number.
    set ccurrent [lindex $cimages $index]
    set cshown   [lsearch -exact $cimages $ccurrent]
    set cflags   [lassign [m/get $ccurrent] image]

    view/show $side $select $cshown $image {*}$cflags
    view/status [expr {1+$cshown}]/[llength $cimages]
    return
}

proc c/show/none {side} {
    view/show/none $side
    view/status {}
    return
}

proc c/show/first {side} {
    c/show $side 0
    return
}

proc c/show/last {side} {
    c/show $side end
    return
}

proc c/show/next {side} {
    c/show $side [c/advance $side]
    return
}

proc c/show/previous {side} {
    c/show $side [c/advance $side -1]
    return
}

proc c/advance {side {step 1}} {
    upvar #0 \
	cshown($side)   cshown \
	cimages($side)  cimages

    set n $cshown
    incr n $step
    if {$n < 0} {
	set n [llength $cimages]
	incr n -1
    } elseif {$n >= [llength $cimages]} {
	set n 0
    }
    return $n
}

# XXX
proc c/apply/selection {label script} {
    global cchosen cflags ccurrent cshown
    if {![llength $cchosen]} return
    action disable
    set saved $cshown
    set count 0
    set max [llength $cchosen]
    foreach sel $cchosen {
	view/status "\[$label [expr {1+$sel}]\] [incr count]/$max"
	view/progress/tick
	update
	c/load $sel
	lassign $cflags u e c a o
	eval $script
	m/set $ccurrent $u $e $c $a $o
	c/load $sel
    }
    c/show $saved 0
    action enable
    view/progress/reset
    return
}

# XXX
proc c/toggle/attention {} {
    c/apply/selection {toggle attention} {
	set a [expr {!$a}]
    }
    return
}

# XXX
proc c/toggle/used {} {
    c/apply/selection {toggle used} {
	set u [expr {!$u}]
    }
    return
}

# XXX
proc c/mark/cover_front {} {
    c/apply/selection {front cover/west} {
	set e 0 ; # odd == right == front
	set c 0 ; # cover
	set o 2 ; # west
    }
    return
}

# XXX
proc c/mark/cover_back {} {
    c/apply/selection {back cover/east} {
	set e 1 ; # even == left == back
	set c 0 ; # cover
	set o 0 ; # east
    }
    return
}

# XXX
proc c/mark/even {even} {
    # Note: orientation derived from left/right
    # Explicit orientation must be done after l/r classification
    global omap
    set w [expr {$even ? "left/even" : "right/odd"}]
    set theorient [expr {$even ? "east" : "west"}]
    set orient $omap($theorient)
    c/apply/selection $w/$theorient {
	upvar 1 even even orient orient
	set e $even
	set o $orient
    }
    return
}

# XXX
proc c/mark/content {page} {
    set w [expr {$page ? "content" : "cover"}]
    c/apply/selection $w {
	upvar 1 page page
	set c $page
    }
    return
}

array set omap {
    0 0 east  0
    1 1 south 1
    2 2 west  2
    3 3 north 3
}

array set oicon {
    0 arrow_right  east  arrow_right
    1 arrow_down   south arrow_down
    2 arrow_left   west  arrow_left
    3 arrow_up     north arrow_up
}

# XXX
proc c/orient {theorient} {
    global omap
    set orient $omap($theorient)
    c/apply/selection $theorient {
	upvar 1 orient orient
	set o $orient
    }
    return
}

# # ## ### ##### ######## ############# #####################
## Model

proc model {} {
    # nothing at the moment
    return
}

proc m/initialize {args} {
    after 0 $args
    return
}

proc m/get {imgpath} {
    set image [BOOK upright?   $imgpath]
    set flags [BOOK indicator? $imgpath]
    dict with flags {}
    return [list $image $used $even $content $attention $orientation]
}

proc m/set {imgpath used even content attention orientation} {
    #puts "m/set |$imgpath i$used e$even c$content a$attention|"
    BOOK indicator $imgpath \
	[dict create            \
	     used        $used   \
	     even        $even    \
	     content     $content  \
	     attention   $attention \
	     orientation $orientation]
    return
}

proc m/list/left {} {
    set mimages  {}
    set images [BOOK images-left]
    foreach i $images {
	set flags [BOOK indicator? $i]
	dict with flags {}
	lappend mimages \
	    [list $i $used $even $content $attention]
    }

    return [list $images $mimages]
}

proc m/list/right {} {
    set mimages  {}
    set images [lreverse [BOOK images-right]]
    foreach i $images {
	set flags [BOOK indicator? $i]
	dict with flags {}
	lappend mimages \
	    [list $i $used $even $content $attention]
    }

    return [list $images $mimages]
}

# # ## ### ##### ######## ############# #####################

main
exit
